# RANDASM templates for MCS51 using the ASEM51 syntax.
# 
# NOTE:
# The templates don't include ACALL or AJMP instructions, because randasm
# is not smart enough to guarantee that the target address is within the 
# same code page. 
# I've used JMP and CALL instead; pseudoinstructions defined by ASEM51 for 
# these cases. These will in some cases assemble into absolute versions, see
# the ASEM51 documentation. 
# 

tab-stops: [8, 16, 24]

arguments:
  imm8:
    type: literal
    format: "#0%02xh"
    range: [0, 255]
  dir:
    type: literal
    format: 0%02xh
    range: [0, 255]
  bit:
    type: literal
    format: 0%02xh
    range: [0, 255]
  reg:
    type: choice
    choices: [r0, r1, r2, r3, r4, r5, r6, r7]
  indir:
    type: choice
    choices: ['@r0', '@r1']
  arith:
    type: choice
    choices: [add, addc, subb]
  arith-uni:
    type: choice
    choices: [inc, dec]
  logic:
    type: choice
    choices: [anl, orl, xrl]
  jxx:
    type: choice
    choices: [jc, jnc, sjmp]
  jbit:
    type: choice
    choices: [jb, jnb, jbc]
    # FIXME See header comments about ajmp.
  jumpx:
    type: choice
    choices: [jmp, ljmp]
    # FIXME See header comments about acall.
  callx:
    type: choice
    choices: [call, lcall]
  retx:
    type: choice
    choices: [ret, reti]
  dir-imm8:
    type: choice
    choices: [dir, imm8]
  reg-indir:
    type: choice
    choices: [indir, reg]
  dir-reg:
    type: choice
    choices: [dir, reg]


blocks:
  - $(arith) a, $(reg)
  - $(arith) a, $(dir)
  - $(arith) a, $(indir)
  - $(arith) a, $(imm8)
  - $(arith-uni) $(reg)
  - $(arith-uni) $(dir)
  - $(arith-uni) $(indir)
  - $(arith-uni) a
  - da a
  - clr a
  - cpl a 
  - rl a
  - rlc a
  - rr a
  - rrc a
  - swap a
  - mul ab
  - div ab
  - $(logic) a, $(reg)
  - $(logic) a, $(dir)
  - $(logic) a, $(indir)
  - $(logic) a, $(imm8)
  - $(logic) $(dir), a
  - $(logic) $(dir), $(imm8)
  - mov a, $(reg)
  - mov a, $(dir)
  - mov a, $(indir)
  - mov a, $(imm8)
  - mov $(reg), $(dir)
  - mov $(reg), a
  - mov $(reg), $(imm8)
  - mov $(dir), $(dir)
  - mov $(dir), a
  - mov $(dir), $(reg)
  - mov $(dir), $(indir)
  - mov $(dir), $(imm8)
  - nop
  - clr c
  - clr $(bit)
  - setb c
  - setb $(bit)
  - cpl c
  - cpl $(bit)
  - anl c, $(bit)
  - anl c, /$(bit)
  - orl c, $(bit)
  - orl c, /$(bit)
  - mov c, $(bit)
  - mov $(bit), c
  # CJNE -- jump backwards.
  - |
    $(def-label:0)
    $(ins-random:4)
    cjne a, $(dir-imm8), $(ref-label:0) 
  - |
    $(def-label:0)
    $(ins-random:4)
    cjne $(reg-indir), $(imm8), $(ref-label:0) 
  # CJNE -- jump forwards.
  - |
    cjne a, $(dir-imm8), $(ref-label:0)
    $(ins-random:4)
    $(def-label:0)
  - |
    cjne $(reg-indir), $(imm8), $(ref-label:0) 
    $(ins-random:4)
    $(def-label:0)
  # DJNZ -- jump backwards and forwards.
  - |
    $(def-label:0)
    $(ins-random:4)
    djnz $(dir-reg), $(ref-label:0) 
  - |
    djnz $(dir-reg), $(ref-label:0) 
    $(ins-random:4)
    $(def-label:0)
  # Relative conditional Jxx -- jump backwards and forwards.
  - |
    $(def-label:0)
    $(ins-random:4)
    $(jxx) $(ref-label:0) 
  - |
    $(jxx) $(ref-label:0) 
    $(ins-random:4)
    $(def-label:0)
  # Relative bit-test Jxx -- jump backwards and forwards.
  - |
    $(def-label:0)
    $(ins-random:4)
    $(jbit) $(bit), $(ref-label:0) 
  - |
    $(jbit) $(bit), $(ref-label:0) 
    $(ins-random:4)
    $(def-label:0)
  # Absolute unconditional jump backwards -- cheat a bit to avoid endless loops.
  - |
    sjmp $(ref-label:1) 
    $(def-label:0)
    $(ins-random:4)
    sjmp $(ref-label:2)
    $(def-label:1)
    $(jumpx) $(ref-label:0) 
    $(def-label:2)
  # Absolute unconditional jump forwards.
  # FIXME ljump assembly may fail if block straddles a page boundary.
  - |
    $(jumpx) $(ref-label:0) 
    $(ins-random:4)
    $(def-label:0)
  # Calls (not meant to be returned from).
  # FIXME lcall assembly may fail if block straddles a page boundary.
  - |
    $(callx) $(ref-label:0) 
    $(ins-random:4)
    $(def-label:0)
  - |
    sjmp $(ref-label:1) 
    $(def-label:0)
    $(ins-random:4)
    sjmp $(ref-label:2)
    $(def-label:1)
    $(callx) $(ref-label:0) 
    $(def-label:2)
  # Returns, backwards and forwards.
  - |
    lcall $(ref-label:0)
    sjmp $(ref-label:1)
    $(def-label:0)
    $(ins-random:4)
    $(retx)
    $(def-label:1)
  - |
    sjmp $(ref-label:0)
    $(def-label:1)
    $(ins-random:4)
    $(retx)
    $(def-label:0)
    $(ins-random:4)
    lcall $(ref-label:1)

wrapper: |
          ; Assembly wrapper for random autogenerated source.
                  $nomod51

                  org     00h
                  ljmp    start               ; We'll assume LJMP works this far...
                  org     03h
                  org     0bh
                  org     13h
                  org     1bh
                  org     23h

                  org     30h
          start:

          $(sequence)

                  end
